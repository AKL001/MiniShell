handle redir is being called 2 time in a single command 
int	handle_redirections(t_command *cmd)
{
	t_redir	*redir;
	int		first_in;
	int		first_out;

	first_in = -1;
	first_out = -1;
	redir = cmd->redirections;
	printf("*****handle redir called*****\n");
	while (redir)
	{
		if (redir->type == REDIR_HEREDOC)
		{
			if (first_in != -1)
				close(first_in);
			printf("here_doc fd  = %d\n",redir->heredoc_fd);
			first_in = redir->heredoc_fd;
			// if (read_heredoc(redir, &first_in) == 1)
			// 	return -1;
			// break;
			// if (read_heredoc(redir, &first_in) == -1)
			// 	return (-1);
		}
		if (redir->type == REDIR_IN)
		{
			if (handle_input_redir(redir, &first_in) == -1)
				return (-1);
		}
		else if (redir->type == REDIR_OUT || redir->type == REDIR_APPEND)
		{
			if (handle_output_redir(redir, &first_out) == -1)
				return (-1);
		}
		redir = redir->next;
	}
	if (first_in != -1 && dup2(first_in, STDIN_FILENO) == -1)
		return (error_message("dup2", 1));
	if (first_out != -1 && dup2(first_out, STDOUT_FILENO) == -1)
		return (error_message("dup2", 1));
	// printf("first_in = %d , first_out = %d\n",first_in,first_out);
	close(first_in);
	close(first_out);
	return (0);
}

int	handle_redirections(t_command *cmd)
{
	t_redir	*redir;
	int		first_in;
	int		first_out;

	first_in = -1;
	first_out = -1;
	redir = cmd->redirections;
	while (redir)
	{
		if ((redir->type == REDIR_IN || redir->type == REDIR_HEREDOC)
			&& handle_input_redir(redir, &first_in) == -1)
			return (-1);
		else if ((redir->type == REDIR_OUT || redir->type == REDIR_APPEND)
			&& handle_output_redir(redir, &first_out) == -1)
			return (-1);
		redir = redir->next;
	}
	if (first_in != -1)
    {
        if (dup2(first_in, STDIN_FILENO) == -1)
            return (error_message("dup2 failed", 1));
        close(first_in); // Close after dup2
    }
    if (first_out != -1)
    {
        if (dup2(first_out, STDOUT_FILENO) == -1)
            return (error_message("dup2 failed", 1));
        close(first_out); // Close after dup2
    }
	return (0);
}


int setup_pipes(t_command *cmd, int input_fd, t_env *env, pid_t *child_pids, int *pid_count) {
    int pipefd[2];
    pid_t pid;

	
    if (!cmd->next) {
        pid = fork();
        if (pid == -1)
            return error_message("fork", 1);
        if (pid == 0) {
            if (input_fd != STDIN_FILENO) {
                dup2(input_fd, STDIN_FILENO);
                close(input_fd);
            }
            execute_command(cmd, env);
            exit(g_vars.g_exit_status);
        } else {
            child_pids[(*pid_count)++] = pid;
            if (input_fd != STDIN_FILENO)
                close(input_fd);
            return 0;
        }
    }

    if (pipe(pipefd) == -1)
        return error_message("pipe", 1);

    pid = fork();
    if (pid == -1)
        return error_message("fork", 1);

    if (pid == 0) {
        close(pipefd[0]);
        if (input_fd != STDIN_FILENO) {
            dup2(input_fd, STDIN_FILENO);
            close(input_fd);
        }
        dup2(pipefd[1], STDOUT_FILENO);
        close(pipefd[1]);
        if (handle_redirections(cmd) == -1)
            exit(1);
        execute_command(cmd, env);
        exit(g_vars.g_exit_status);
    } else {
        child_pids[(*pid_count)++] = pid;
        close(pipefd[1]);
        if (input_fd != STDIN_FILENO)
            close(input_fd);
        setup_pipes(cmd->next, pipefd[0], env, child_pids, pid_count);
        close(pipefd[0]);
    }
    return 0;
}

int execute_command_line(t_command *cmd, t_env *env) {
    int stdin_copy = dup(STDIN_FILENO);
    int stdout_copy = dup(STDOUT_FILENO);
    pid_t child_pids[100];
    int pid_count = 0;
	int i;
    int status;

    if (!cmd)
        return 0;

    if (cmd->next) {
        setup_pipes(cmd, STDIN_FILENO, env, child_pids, &pid_count);
    } else {
        pid_t pid = fork();
        if (pid == -1)
            return error_message("fork", 1);
        if (pid == 0) {
            execute_command(cmd, env);
            exit(g_vars.g_exit_status);
        } else {
            child_pids[pid_count++] = pid;
        }
    }
	i = -1;
	while(++i < pid_count)
	{
		waitpid(child_pids[i],&status,0);
		if (WIFEXITED(status))
            g_vars.g_exit_status = WEXITSTATUS(status);
	}
	// Restore stdin/stdout
    dup2(stdin_copy, STDIN_FILENO);
    dup2(stdout_copy, STDOUT_FILENO);
    close(stdin_copy);
    close(stdout_copy);
	printf("\033[1;32mg_exit_status => \033[1;36m%d\033[0m\n", g_vars.g_exit_status);
    return g_vars.g_exit_status;
}



///////////////////////////////////////////////////


static void	child_process_exec(t_command *cmd, t_env *env)
{
	char	*cmd_path;
	char	**args_arr;
	char	**env_arr;

	if (handle_redirections(cmd) == -1)
		exit(1);
	cmd_path = find_command_path(cmd->args->value, env);
	//  EXIT_COMMAND_NOT_FOUND 127
	if (!cmd_path)
		exit(error_message(cmd->args->value, 127));
	args_arr = args_to_array(cmd->args);
	env_arr = env_to_array(env);
	if(execve(cmd_path, args_arr, env_arr) == -1)
	{
		// EXIT_CANNOT_EXECUTE 126 
		error_message(cmd->args->value, 126);
		// printf("command not found 126\n");
		write(1, "command not found\n",18);
		free(cmd_path);
		free_array(args_arr);
		free_array(env_arr);
		exit(126);
	}
}

int	execute_simple_command(t_command *cmd, t_env *env)
{
	pid_t	pid;
	int		status;

	if (!cmd->args)
		return (0);
	if (execute_builtin(cmd, &env))
		return (1);
	pid = fork();
	if (pid == -1)
		return (error_message("fork", 1));
	if (pid == 0)										// simple command child 
		child_process_exec(cmd, env);
	printf("last command pid => %d\n",pid);
	waitpid(pid, NULL, 0);
	// if (WIFEXITED(status))
	// 	g_vars.g_exit_status = WEXITSTATUS(status);
	return (g_vars.g_exit_status);
}


int	execute_multiple_pipe_command(t_command *cmd, t_env *env)
{
	char	*cmd_path;
	char	**args_arr;
	char	**env_arr;

    // if (!cmd->args)
	// 	return (0);
	if (handle_redirections(cmd) == -1)
		exit(1);
	if (execute_builtin(cmd, &env))
		return g_vars.g_exit_status;
	cmd_path = find_command_path(cmd->args->value, env);
	if (!cmd_path)
	{
		// Command not found 127
        printf("command not found executed -----\n");
		error_message(cmd->args->value, 127);
		exit(127);
	}
	args_arr = args_to_array(cmd->args);
	// env_arr = env_to_array(env);
	execve(cmd_path, args_arr, env_to_array(env));
    error_message(cmd->args->value, 126);
    free(cmd_path);
    free_array(args_arr);
    free_array(env_arr);
    exit(126);
}


// int handle_redirections(t_command *cmd)
// {
//     t_redir *r = cmd->redirections;
//     int in_fd = -1;
//     int out_fd = -1;

//     while (r)
//     {
//         if (r->type == REDIR_HEREDOC)
//         {
//             if (in_fd != -1)
//                 close(in_fd);
//             in_fd = dup(r->heredoc_fd);  // Duplicate the heredoc FD
//             if (in_fd == -1)
//                 return (-1);
//         }
//         else if (r->type == REDIR_IN && handle_input_redir(r, &in_fd) == -1)
//             return (-1);
//         else if ((r->type == REDIR_OUT || r->type == REDIR_APPEND) &&
//                 handle_output_redir(r, &out_fd) == -1)
//             return (-1);
//         r = r->next;
//     }
//     if (in_fd != -1)
//         if (dup2(in_fd, STDIN_FILENO) == -1 || close(in_fd) == -1)
//             return (-1);
//     if (out_fd != -1)
//         if (dup2(out_fd, STDOUT_FILENO) == -1 || close(out_fd) == -1)
//             return (-1);
//     return (0);
// }

// int	handle_redirections(t_command *cmd)
// {
// 	t_redir	*r;
// 	int		in_fd;
// 	int		out_fd;

// 	r = cmd->redirections;
// 	in_fd = -1;
// 	out_fd = -1;
// 	while (r)
// 	{
// 		if (r->type == REDIR_HEREDOC)
//         {
//             if (in_fd != -1)
//                 close(in_fd);
//             in_fd = r->heredoc_fd;  // Duplicate the heredoc FD
//             if (in_fd == -1)
//                 return (-1);
//         }
// 		if (r->type == REDIR_IN && handle_input_redir(r, &in_fd) == -1)
// 			return (-1);
// 		if ((r->type == REDIR_OUT || r->type == REDIR_APPEND)
// 			&& handle_output_redir(r, &out_fd) == -1)
// 			return (-1);
// 		r = r->next;
// 	}
// 	if (in_fd != -1 && (dup2(in_fd, STDIN_FILENO) || 1))
// 		close(in_fd);
// 	if (out_fd != -1 && (dup2(out_fd, STDOUT_FILENO) || 1))
// 		close(out_fd);
// 	return (0);
// }




// static int	handle_input_redir(t_redir *redir, int *first_in)
// {
// 	if (*first_in != -1)
// 		return (0);
// 	*first_in = open(redir->filename, O_RDONLY);
// 	if (*first_in == -1)
// 		return (error_message(redir->filename, 1));
// 	return (0);
// }

// static int	handle_output_redir(t_redir *redir, int *first_out)
// {
// 	int	fd;
// 	int	flags;

// 	flags = O_WRONLY | O_CREAT;
// 	if (redir->type == REDIR_OUT)
// 		flags |= O_TRUNC;
// 	else
// 		flags |= O_APPEND;
// 	fd = open(redir->filename, flags, 0644);
// 	if (fd == -1)
// 		return (error_message(redir->filename, 1));
// 	if (*first_out == -1)
// 		*first_out = fd;
// 	else
// 		close(fd);
// 	return (0);
// }

// int handle_redirections(t_command *cmd)
// {
//     t_redir *r = cmd->redirections;
//     int in_fd = -1;
//     int out_fd = -1;
//     while (r)
//     {
//         if (r->type == REDIR_HEREDOC)
//         {
//             if (in_fd != -1) close(in_fd);
//             in_fd = r->heredoc_fd;
//         }
//         if (r->type == REDIR_IN)
// 		{
// 			if (handle_input_redir(r, &in_fd) == -1)
// 				return (-1);
// 		}
// 		if (r->type == REDIR_OUT || r->type == REDIR_APPEND)
// 		{
// 			if (handle_output_redir(r, &out_fd) == -1)
// 				return (-1);
// 		}
//         r = r->next;
//     }

//     if (in_fd != -1) dup2(in_fd, STDIN_FILENO);
//     if (out_fd != -1) dup2(out_fd, STDOUT_FILENO);
    
//     if (in_fd != -1) close(in_fd);
//     if (out_fd != -1) close(out_fd);
    
//     return 0;
// }

// int	execute_command(t_command *cmd, t_env *env)
// {
// 	char	*cmd_path;
// 	char	**args_arr;
// 	char	**env_arr;

//     // if (!cmd->args)
// 	// 	return (0);
// 	if (handle_redirections(cmd) == -1)
// 		return 1;
// 	if (execute_builtin(cmd, &env))
// 		return g_vars.g_exit_status;
// 	cmd_path = find_command_path(cmd->args->value, env);
// 	if (!cmd_path)
// 	{
// 		// Command not found 127
// 		error_message(cmd->args->value, 127);
// 		return 127;
// 	}
// 	args_arr = args_to_array(cmd->args);
// 	execve(cmd_path, args_arr, env_to_array(env));
//     error_message(cmd->args->value, 126);
//     free(cmd_path);
//     free_array(args_arr);
//     free_array(env_arr);
//     return 126;
// }



// int setup_pipes(t_command *cmd, int input_fd, t_env *env, pid_t *child_pids, int *pid_count) {
//     int pipefd[2];
//     pid_t pid;
//     int exit_status;

//     if (!cmd->next) {
//         pid = fork();
//         if (pid == -1)
//             return error_message("fork", 1);
//         if (pid == 0) {
//             if (input_fd != STDIN_FILENO) {
//                 dup2(input_fd, STDIN_FILENO);
//                 close(input_fd);
//             }
//             g_vars.g_exit_status = execute_command(cmd, env);
//             exit(g_vars.g_exit_status);
//         } else {
//             child_pids[(*pid_count)++] = pid;
//             if (input_fd != STDIN_FILENO)
//                 close(input_fd);
//             return 0;
//         }
//     }
//     if (pipe(pipefd) == -1)
//         return error_message("pipe", 1);

//     pid = fork();
//     if (pid == -1)
//         return error_message("fork", 1);

//     if (pid == 0) {
//         close(pipefd[0]);
//         if (input_fd != STDIN_FILENO) {
//             dup2(input_fd, STDIN_FILENO);
//             close(input_fd);
//         }
//         dup2(pipefd[1], STDOUT_FILENO);
//         close(pipefd[1]);
//         g_vars.g_exit_status = execute_command(cmd, env);
//         exit(g_vars.g_exit_status);
//     } else {
//         child_pids[(*pid_count)++] = pid;
//         close(pipefd[1]);
//         if (input_fd != STDIN_FILENO)
//             close(input_fd);
//         setup_pipes(cmd->next, pipefd[0], env, child_pids, pid_count);
//         close(pipefd[0]);
//     }
//     return 0;
// }

// int execute_command_line(t_command *cmd, t_env *env) {
//     int stdin_copy;
//     pid_t child_pids[100];
//     int pid_count = 0;
//     int i;
//     int status;
// 	t_redir *redir;
// 	t_command *current;

//     if (!cmd)
//         return 0;
//     // stdin_copy = dup(STDIN_FILENO);
// 	current = cmd;
//     while (current) {
//         redir = current->redirections;
//         while (redir) {
//             if (redir->type == REDIR_HEREDOC) {
//                 if (read_heredoc(redir, &redir->heredoc_fd) == -1) {
//                     // close(stdin_copy);
//                     return 1;
//                 }
//             }
//             redir = redir->next;
//         }
//         current = current->next;
//     }
//     if (cmd->next)
// 	{
// 		// printf("multiple pipe execution\n");
//         // close(stdin_copy);
//         setup_pipes(cmd, STDIN_FILENO, env, child_pids, &pid_count);
//     }
// 	else
// 	{
// 		// printf("\033[0;33mSingle command execution\033[0m\n");
//         pid_t pid = fork();
//         if (pid == -1)
//         {
//             // close(stdin_copy);
//             return error_message("fork", 1);
//         }
//         if (pid == 0) {
//             // printf("single command ??\n");
//             // close(stdin_copy);
//             g_vars.g_exit_status = execute_command(cmd, env);
//             exit(g_vars.g_exit_status);
//         } else {
//             child_pids[pid_count++] = pid;
//         }
//     }
//     i = -1;
//     while(++i < pid_count)
//     {
//         waitpid(child_pids[i], &status, 0);
//         if (WIFEXITED(status))
//             g_vars.g_exit_status = WEXITSTATUS(status);
//     }
    
// 	current = cmd;
//     while (current) {
//         redir = current->redirections;
//         while (redir) {
//             if (redir->type == REDIR_HEREDOC && redir->heredoc_fd != -1) {
//                 close(redir->heredoc_fd);
//                 redir->heredoc_fd = -1; // Mark as closed
//             }
//             redir = redir->next;
//         }
//         current = current->next;
//     }
//     // if (stdin_copy != -1)
//     // {
//     //     dup2(stdin_copy, STDIN_FILENO);
//     //     close(stdin_copy);
//     // }
    
//     // printf("\033[1;32mg_exit_status => \033[1;36m%d\033[0m\n", g_vars.g_exit_status);
//     return g_vars.g_exit_status;
// }

/*                cddddddddddddddddddddddddddddddddddddddddd  */

// void	my_cd(char **args, t_env *env)
// {
// 	char	*home_dir;
// 	char	*old_pwd;
// 	char	current_dir[1024];
// 	char	*target_dir;
// 	t_env	*current;

// 	home_dir = NULL;
// 	old_pwd = NULL;
// 	if (getcwd(current_dir, sizeof(current_dir)) == NULL)
// 		if (error_message("getcwd", 1) == -1)
// 			return ;
// 	current = env;
// 	while (current)
// 	{
// 		if (ft_strcmp(current->key, "HOME") == 0)
// 		{
// 			home_dir = current->value;
// 			break ;
// 		}
// 		current = current->next;
// 	}
// 	current = env;
// 	while (current)
// 	{
// 		if (strcmp(current->key, "OLDPWD") == 0)
// 		{
// 			old_pwd = current->value;
// 			break ;
// 		}
// 		current = current->next;
// 	}
// 	if (args[1] == NULL)
// 	{
// 		if (home_dir == NULL)
// 			if(error_message("cd: HOME not set", 1))
// 				return ;
// 		target_dir = home_dir;
// 	}
// 	else
// 		target_dir = args[1];
// 	if (chdir(target_dir) == -1)
// 	{
// 		if(error_message("cd: ", 1))
// 			return ;
// 	}
// 	else
// 	 	g_vars.g_exit_status = 0;
// 	update_env(env, "OLDPWD", current_dir);
// 	if (getcwd(current_dir, sizeof(current_dir)) != NULL)
// 		update_env(env, "PWD", current_dir);
// 	else
// 		error_message("getcwd", 1);
// }



// int	read_heredoc(t_redir *heredoc, int *heredoc_fd)
// {
// 	char	*line;
// 	char	temp_filename[] = ".heredoc_temp";
// 	int		temp_fd;
// 	char	*delimiter;

// 	delimiter = heredoc->filename;
// 	temp_fd = open(temp_filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
// 	if (temp_fd == -1)
// 		return (error_message("heredoc temp file", 1));
// 	while (1)
// 	{
// 		write(STDOUT_FILENO, "> ", 2);
// 		line = ft_read_until_newline(STDIN_FILENO);
// 		if (!line)
// 			break;
		
// 		// Trim newline and compare
// 		if (line[ft_strlen(line)-1] == '\n')
// 			line[ft_strlen(line)-1] = '\0';
		
// 		if (ft_strcmp(line, delimiter) == 0)
// 		{
// 			free(line);
// 			// close(stdin_copy);
// 			break;
// 		}
		
// 		// Restore newline for writing
// 		write(temp_fd, line, ft_strlen(line));
// 		write(temp_fd, "\n", 1);
// 		free(line);
// 	}
// 	close(temp_fd);
// 	// Open for reading and clean up
// 	*heredoc_fd = open(temp_filename, O_RDONLY);
// 	unlink(temp_filename);
// 	if (*heredoc_fd == -1)
// 		return (error_message("heredoc read", 1));
// 	return (0);
// }



/*   last redir */

// int handle_redirections(t_command *cmd)
// {
//     t_redir *r = cmd->redirections;
//     int in_fd = -1;
//     int out_fd = -1;
//     int last_input_type = 0;

//     r = cmd->redirections;
//     while (r)
//     {
//         if (r->type == REDIR_IN && !last_input_type)
//         {
//             if (in_fd != -1)
//                 close(in_fd);
//             if (handle_input_redir(r, &in_fd) == -1)
//                 return (-1);
//             last_input_type = 1;
//         }
//         else if (r->type == REDIR_HEREDOC && !last_input_type)
//         {
//             if (in_fd != -1)
//                 close(in_fd);
//             in_fd = r->heredoc_fd;
//             last_input_type = 1;
//         }
//         r = r->next;
//     }
//     r = cmd->redirections;
//     while (r)
//     {
//         if (r->type == REDIR_OUT || r->type == REDIR_APPEND)
//         {
//             if (handle_output_redir(r, &out_fd) == -1)
//                 return (-1);
//         }
//         r = r->next;
//     }
//     if (in_fd != -1)
//         if (dup2(in_fd, STDIN_FILENO) == -1 || close(in_fd) == -1)
//             return (-1);
//     if (out_fd != -1)
//         if (dup2(out_fd, STDOUT_FILENO) == -1 || close(out_fd) == -1)
//             return (-1);
    
//     return 0;
// }

